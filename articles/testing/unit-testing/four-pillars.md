# 良い単体テストを構成する4本の柱

優れた単体テストのテストスイートは、最小限の保守コストで最大限の価値を生み出す。
これを実現するためには、価値のあるテストケースを認識できなければならない。
テストケースを分析するのに使う基準となる枠組みであり、良い単体テストを構成する4本の柱は以下である。

- リグレッションに対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

## リグレッションに対する保護

以下の観点に着目すると、より多くのリグレッションを防ぐことができる。

- テスト時に実行されるプロダクションコードの量
  - 量が増えるほど、リグレッションが見つかる可能性は高くなる
- テスト対象のコードの複雑さ
  - ビジネスロジックのコードは複雑なほど重要になる
- テスト対象のコードのドメインにおける重要性
  - ビジネス的に重要な機能ほど、バグによる被害も大きい

重要でないコードをテストする価値はほとんどない。

アプリケーションに対する影響が大きいため、ライブラリやフレームワークのコードも考慮する必要がある。

## リファクタリングへの耐性

偽陽性(false positive)とは、テスト対象のコードには問題がないのにテストが失敗すること。
プロダクションコードをリファクタリングする際に起こる。
リファクタリングへの耐性とは、リファクタリングを行なっても偽陽性が生まれにくい性質のこと(と本書では呼ぶ)。

リファクタリングへの耐性があるか評価するには、そのテストケースを実行することでどのくらいの偽陽性が発生するのか計測する。

単体テストによって、

- バグを検出できる
- プロダクションコードを変更してもテストを実行できるので、リファクタリングをしようと思える

しかし、偽陽性に対して注意を払わないと、テストが失敗することに慣れてしまいテスト結果を重要視しなくなる。

## 偽陽性を引き起こす原因

偽陽性を防ぐには、検証する対象を実装の詳細ではなく、最終的な結果(観測可能な振る舞い)のみに絞る。
テストケースを作成する際は、それが問題領域に関する物語(Story)を伝えているかを意識する。
検証対象が実装の詳細の場合、リファクタリングするとテストが壊れる。

## コードの正確性とテストの結果との関係

|              |      | 実際の振る舞い                              |                                               |
| ------------ | ---- | ------------------------------------------- | --------------------------------------------- |
|              |      | 正しい                                      | 間違い                                        |
| テストの結果 | 成功 | 真陰性(正しい推断)                          | 偽陰性(第二種過誤) リグレッションに対する保護 |
|              | 失敗 | 偽陽性(第一種過誤) リファクタリングへの耐性 | 真陽性(正しい推断)                            |

偽陽性や偽陰性の可能性が低ければ、そのテストは正確性が高い。
つまり、リグレッションに対する保護とリファクタリングへの耐性を備えることは、テストの正確性を高くする。

テストの正確性を評価する別の方法に信号対ノイズ比がある。
テストの正確性 = 信号(検出されたバグの数) / ノイズ(嘘の警告が発せられた数)

## 偽陽性と偽陰性の重要性の違い

プロジェクトが成長するにつれ、偽陽性は偽陰性と同じくらい重要になる。

## 迅速なフィードバック

テストを速やかに行うようになると、用意されるテストケースも増え、テストの頻度も高くなる。
そして、フィードバックを得てから改善するまでの時間も劇的に短くなり、バグをすぐに検出できるようになる。

## 保守のしやすさ

保守のしやすさは以下の観点から把握することができる。

- テストケースの理解のしやすさ
- テストの行いやすさ

## 理想的なテストの探求

テストケースの価値は4本の柱の掛け算である。
1本でも0になってしまうと、そのテストケースの価値はなくなる。
最初の3本の柱は互いに排反する性質であるため、すべて最大限に備えることはできない。

保守のしやすさは他の柱との関連性はない。
E2Eテストに関しては、すべての依存をきちんと準備しなくてはならないため、保守コストは高くなる。

単体テストのテストケースを作成する際は、どの柱を優先し、どの柱を犠牲にするか決断する必要がある。
リファクタリングへの耐性は、備えられるか否かなので、犠牲にすることはできない。
そのためには作成するテストケースに対して、十分な実行速度を持たせなくてはならない。つまり、E2Eテストのみではいけない。

理想のテストは、リファクタリングへの耐性と保守のしやすさを最大限に備えたものである。
リグレッションに対する保護と迅速なフィードバックのバランスを調整する必要がある。

### 3本の柱のうち1本を犠牲にした極端な例

#### E2Eテスト

E2Eテストは、多くのプロダクションコードが実行されるため、リグレッションに対する保護を十分に備えている。
偽陽性も持ち込まれにくいため、リファクタリングへの耐性がもっとも備わった種類のテストである。
しかし、テストを実行し終えるまでに時間がかかるため、迅速なフィードバックを得ることが難しくなる。

#### 取るに足らないテスト

実行時間が短く、偽陽性が持ち込まれる可能性も低い。
しかし、テスト対象のコードに間違いが存在する可能性がほとんどないため、リグレッションが検出されることはほとんどない。

#### 壊れやすいテスト

実行時間が短く、リグレッションを見つけることはできる。
しかし、実装の詳細に結び付いているため、リファクタリングへの耐性が備わっていない。

## テストピラミッド

ピラミッド状に以下のテストを重ねたもの。
幅が大きいほどテストケースが多く、高いほどエンドユーザの視点に近くなる。

- E2Eテスト
- 統合テスト
- 単体テスト

高い層ほどリグレッションに対する保護をより備えなくてはならず、低い層ほど迅速なフィードバックを備えなくてはならない。
どの層もリファクタリングへの耐性を最大限に備えなくてはならない。

E2Eテストはコード量が多く、そして、プロセス外依存も含めて保守しなくてはならないため、保守コストが高い。
そして、リグレッションに対する保護がもっとも備わっているため、非常に重要な機能にのみ使用する。

### テストピラミッドの例外

テスト対象のアプリケーションが基本的なCRUD操作しか行わない場合は、統合テストの方が単体テストよりも多くなる。
単体テストは、検証すべきアルゴリズムやビジネスロジックがなければ、その有用性は失われる。

1つのプロセス外依存(例えばデータベース)しか扱わないAPIをテストする場合は、E2Eテストを多く用意する方がより効果的になることがある。
UIを持たないことが多いため、E2Eテストであっても許容範囲内の時間で実施できるからである。
プロセス外依存も1つしかないため、保守コストも低くなる。
よって、E2Eテストと統合テストのあいだに違いが出ることはほとんどない。
違いは、E2Eテストの場合は、テストを実施するプロセスとアプリケーションをホストするプロセスは異なり、統合テストの場合は同じである点である。

## ブラックボックステストとホワイトボックステスト

ブラックボックステストとは、システムの内部を知ることなしに検証するテスト手法である。
ホワイトボックステストとは、システムの内部を検証するテスト手法である。

ホワイトボックステストはエラーを検出しやすい。
しかし、実装の詳細と深く結び付いており、かつ、テストケースからビジネスにおける意味のある振る舞いを認識しづらくなるため、壊れやすい。

リファクタリングへの耐性は備えるか否かしか選択できないため、ブラックボックステストを優先する。
しかし、テスト対象のコードがアルゴリズムにおける複雑さを備えたユーティリティコードであれば例外である。

分析する際はホワイトボックステストの手法を用いることができる。
例えば、コード網羅率を計測するツールを用いて、どの経路がまだ検証されていないかを見つけ出し、
そのことをまったく知らなかったかのように、その経路を経由するテストケースを作成するのである。
